//clone le operazioni del componente componente
operation Component cloneOwnedOperationFrom(componentSource : Component){
	for(op in componentSource.ownedOperation){
		op.cloneOperationInto(self);
	}
}

//aggiungo una nuova operazione al componente
operation Component moveOperation( op : Operation ) : Boolean{
	if(self.ownedOperation.add(op)){
		return true;
	}
	return false;
}

//clone le interface realization del componente
operation Component cloneInterfaceRealizationFrom(component : Component) {
	for(realization in component.interfaceRealization){
		self.interfaceRealization.add(realization.cloneInterfaceRealization());
	}
}

//clone le provideds inteface
operation Component cloneProvidedsFrom(component : Component){
	for(providedInterface in component.getProvideds()){
		self.getProvideds().add(providedInterface);
	}
}

//clone le requireds interface
operation Component cloneRequiredsFrom(component : Component ){
	for(requiredInterface in component.getRequireds()){
		self.getRequireds().add(requiredInterface);
	}
}

//recupero le lifeline del component
operation Component getLifelines() : List(Lifeline){
	var returnValue : List(Lifeline) = new List (Lifeline);
	for(lifeline in Lifeline.allInstances){
		if(lifeline.namespace.isDefined() and lifeline.namespace.hasComponent(self)){
			returnValue.add(lifeline);
		}
	}
	return returnValue;
}

//sposto le provided interfaces sul componente
operation Component moveInterfaceRealizations(interfaceRealization : InterfaceRealization){
	self.interfaceRealization.add(interfaceRealization);
}


operation Component getAllUsedIntefacesProvidedsBy (op : Operation) : List(Interface){
	var returnValue : List(Interface) = new List(Interface);
	
	var listOfUsage = op.getNearestPackage().getUsageRelations();
	
	for (proInterface in self.getProvidedInterfaces() ){
		for(usage in listOfUsage){
			if(usage.supplier->first() == op){
				for(iOp in proInterface.getOwnedOperations()){
					if(usage.client->first() == iOp){
						returnValue.add(proInterface);
						break;
					}
				}
			}
		}
	}
	
	//le sole interfacce utilizzate dall'operzione critica
	for(proInterface in returnValue){
		for(usage in listOfUsage){
			if(usage.supplier->first() <> self and usage.client->first == proInterface){
				returnValue.remove(proInterface);
			}
		}
	}
	
	return returnValue;
}

//recupero la lista delle interfacce richieste
operation Component getAllUsedIntefacesRequiredsBy ( op : Operation ) : List(Interface){
	var returnValue : List(Interface) = new List(Interface);
	var listOfUsage = self.getUsageRelations();
	var listOfRequireds = self.getRequireds();
	for (reqInterface in listOfRequireds){
		for(usage in self.getNearestPackage().getUsageRelations()){
			//TODO
		}
	}
	return returnValue;
}

//recupero la lista di usage proprie del componente
operation Component getUsageRelations() : List(Usage){
	var returnValue : List(Usage) = new List(Usage);
	
	for(relation in Usage.allInstances){
		if( relation.isTypeOf(Usage) and relation.owner == self){
			returnValue.add(relation);
		}
	}
	return returnValue;
}

//recupero la lista degli artifact che manifestano il componente
operation Component getAllArtifacts() : Sequence(Artifact){
	var returnValue : Sequence(Artifact) = new Sequence(Artifact);
	for(manifestation in Manifestation.allInstances){
		if(manifestation.hasUtilizedElement(self)){
			returnValue.addAll(manifestation.client);
		}
	}
	return returnValue;
	
}

//recupero tutte le properties relative al componente negli interaction
operation Component getAllInteractionProperties() : List(Property){
	var returnValue : List(Lifeline) = new List(Lifelinei);
	
	for(interaction in Interaction.allInstances){
		for(prop in interaction.ownedAttribute){
			if(prop.getType() == self){
				returnValue.add(prop);
			}
		}
	}
	
	return returnValue;
}

//recupero tutte le lifeline del componente
operation Component getAllLifelines() : List(Lifeline){
	var returnValue : List(Lifeline) = new List(Lifelinei);
	
	for(lifeline in Lifeline.allInstances){
		for(pro in self.getProperties()){
			if(lifeline.represents == prop){
				returnValue.add(lifeline);
			}
		}
	}
	
}

operation Component getProvidedInterfaces() : Sequence(InterfaceRealization) {
	return self.getInterfaceRealizations()->collect(cd | cd.supplier->first())->asSequence();
}

operation Component getInterfaceRealizations() : Sequence(InterfaceRealization) {
	return self.clientDependency->select(cd | cd.isTypeOf(InterfaceRealization))->asSequence();
}

operation Component getLifeline(interaction : Interaction) : Lifeline{
	for(lf in interaction.getLifelines()){
		if(lf.represents.type == self){
			return lf; //L1
		}	
	}
}

operation Component getManifestations() : List(Manifestation){
	var returnValue : List(Manifestation) = new List(Manifestation);
	for(manifestation in Manifestation.allInstances){
		if(manifestation.getUtilizedElement == self){
			returnValue.add(manifestation);
		}
	}
	return returnValue;
}

operation Component getNodes() : List(Node){
	var returnValue : List(Node) = new List(Node);
	for (artifact in self.getAllArtifacts()){
		for(node in Node.allInstances){
			if( node.hasDeployment(artifact) ){
				returnValue.add(node);
			}
		}
	}

	return returnValue;
}

operation Component moveInterfacesRealizationFrom(component : Component, op : Operation) {
	var listOfUsedProvidedInterfaces : List(Interface) = component.getAllUsedIntefacesProvidedsBy(op);
		
	//sposto le interface realization delle interfacce della listOfUsedProvidedInterfaces 
	//nel nuovo componente
	var selfComponentListOfInterfaceRealizations : List(Interface) = component.getInterfaceRealizations();
	for(intRealization in selfComponentListOfInterfaceRealizations){
		for(interface in listOfUsedProvidedInterfaces){
			if(interface == intRealization.getContract() ){
				self.moveInterfaceRealizations(intRealization);
			}
		}
	}
}

operation Component getOwnedOperations() : List(Operation){
	return self.getOwnedOperations();
}

operation Component deployOnNewNodes(component : Component) {
	
	var listOfNode : List(Node) = component.getNodes();
	
	for(node in listOfNode){
		node.clone(self);		
	}
}

operation Component getNearLessUsedNodes() : List(Node){
	
	var listOfNode = self.getNodes();
	var listOfNearLessUsed : List(Node) = new List(Node);
	
	for(node in listOfNode){
		var listOfNearNode = node.getDirectlyLinkedNode();
		var lessNode : Node = listOfNode->first(); 
		var utilization = lessNode.getValue(lessNode.getStereotype("GaExecHost"), "utilization")->first();
		if(utilization.isUndefined()) utilization = 0.0; //utilizzazione minima
		var i : Integer = 0;
		for(nearNode in listOfNearNode){
			
			var stereotype = listOfNode->first().getStereotype("GaExecHost");
			
			if( nearNode.hasStereotype("GaExecHost") ){
				var nearNodeUtilization = nearNode.getValue(stereotype, "utilization")->first();
				if(nearNodeUtilization.isDefined() and nearNodeUtilization.asReal() < utilization){
					lessNode = nearNode;	
					utilization = nearNodeUtilization;
				}
			}
			i = i+1;
		}
		listOfNearLessUsed.add(lessNode);
	}
	return listOfNearLessUsed;
}

/***********************

	IT MUST BE CHECKED	

************************/
//FIXME Check the behavior
operation Component deployOn(node : Node){
	var newArtifact : Artifact = new Artifact; //creo l'artefatto
	var newManifestation; //e' la manifestazione del componente
	var newDeployment; //e' il deployment dell artefatto appena creato
	
	//aggiungo l'artefatto al package del nodo
	node.getNearestPackage().addElement(newArtifact); 
	//setto il nome dell'artefatto come il componente
	newArtifact.name = self.name; 
	
	//creo la manifestazione del componente sull artefatto
	newManifestation = newArtifact.createManifestation(self.name, self); 
	newDeployment = node.createDeployment(newArtifact.name); //creo il deploy sul nodo
	newDeployment.getDeployedArtifacts().add(newArtifact); //aggiungo al deploy l'artefatto
}

operation Component getNeighbours() : List(Node){
	var listOfNode : List(Node) = new List(Node);
	
	for(node in self.getNodes()){
		var nodeOwnedLink = node.getDirectlyLinkedNode();
		if(nodeOwnedLink.isDefined() and nodeOwnedLink.size() > 0 ){
			listOfNode.addAll(nodeOwnedLink);
		}
	}
	return listOfNode;
}

operation Component redeployOn(node : Node, from : Node){
	var artifact = self.getArtifactOn(from);
	var deployment = self.getDeploymentOn(from, artifact);
	node.getDeployments().add(deployment); //sposto l'artefatto dal nodo sorgente al nuovo nodo
}

operation Component getArtifactOn(node : Node) : Artifact{
	var deploymentNode: Node; 
	for (art in self.getAllArtifacts()){
		deploymentNode = art.getDeploymentNode();
		if(deploymentNode.isDefined() and deploymentNode == node){
			return art;
		}
	}
	return null;
}

operation Component calculateUtilization() : Sequence(Real){
	var ownOperations = self.getOperations(); //recupero le operazioni proprie del componente
	var utilization : Sequence(Real) = new Sequence(Real);
	
	var computationUtilization : Real = 0.0;
	var storageUtilization : Real = 0.0;
	var bandwidthUtilization : Real = 0.0;
	
	for(op in ownOperations){
		if(op.hasStereotype("GaStep") and op.getValue(op.getStereotype("GaStep"), "servCount").isDefined()){
			var sCount = op.getValue(op.getStereotype("GaStep"), "servCount");
			if(not sCount.isEmpty()){
				computationUtilization = computationUtilization + sCount.at(0).asReal(); //computation
				storageUtilization = storageUtilization + sCount.at(1).asReal(); //storage
				bandwidthUtilization = bandwidthUtilization + sCount.at(2).asReal(); //bandwidth
			}
		}
	}
	utilization.add(0,computationUtilization);
	utilization.add(1,storageUtilization);
	utilization.add(2,bandwidthUtilization);
	
	return utilization;
}


operation Component calculateTotalUtilization() : Real{
	var totUtilization : Real = 0.0;
	var i : Integer = 0;
	for (utl in self.calculateUtilization()){
		totUtilization = totUtilization + utl;
		i = i + 1;
	}
	return (totUtilization / i.asReal());
}

operation Component addUsages(usages : Sequence(Usage)){
	for(usage in usages){
		if(usage.isTypeOf(InterfaceRealization)){
			self.moveInterfaceRealizations(usage);
		}else if(usage.isTypeOf(InterfaceRealization)){
			//TODO
		}
	}
}


operation Component getDeploymentOn(node : Node, art : Artifact) : Deployment{
	var returnValue = Deployment.allInstances->selectOne(
		deployment : Deployment | deployment.client->exists(targetNode : Node | targetNode == node) and deployment.supplier->exists(
			deployedArtifact : Artifact | deployedArtifact == art
		)
	);
	return returnValue;
}

operation Component createLifelineInto(interaction : Interaction) : Lifeline {
	var lifeline = interaction.createLifeline(self.name+"lifeline"); //L2
	
	var spProp = interaction.createOwnedAttribute(self.name, self);
	lifeline.setRepresents(spProp);
		
	return lifeline;
}

operation Component getCriticalOperation(){
	var operations = self.getOwnedOperations();
	var criticalOperation : Operation;
	var utilization : Real;
	
	criticalOperation = operations->first();
	utilization = criticalOperation.calculateTotalUtilization();
	
	for (op in operations){
		if(utilization > op.calculateTotalUtilization()){
			utilization = op.calculateTotalUtilization();
			criticalOperation = op;
		}
	}
	
	return criticalOperation;
}
