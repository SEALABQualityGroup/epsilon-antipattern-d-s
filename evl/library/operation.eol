operation Operation FresDemandGreaterOrEqualThan( th_maxOpResDemand : List(Real) ) : Boolean{
	
	var turnback : Boolean = true;
	
	var appliedStereotypes = self.getAppliedStereotypes();
	
	var gaStep = self.getStereotype('GaStep');
	var servCount = self.getValue(gaStep, 'servCount');
	
	var i : Integer = 0;

	for(demand in servCount){
		if(demand.asReal() < th_maxOpResDemand.at(i) ){ //al primo demand non > della soglia relativa ritorna false
			turnback = false;
			break;
		}
		i = i+1;
	}
	
	return turnback;	
}

operation Operation FresDemandLesserThan( th_minOpResDemand : List(Real) ) : Boolean{

	var turnback : Boolean = true;
	
	var appliedStereotypes = self.getAppliedStereotypes();
	
	var gaStep = self.getStereotype('GaStep');
	var servCount = self.getValue(gaStep, 'servCount');
	
	var i : Integer = 0;

	for(demand in servCount){
		if(demand.asReal() >= th_minOpResDemand.at(i) ){ //al primo demand non > della soglia relativa ritorna false
			turnback = false;
			break;
		}
		i = i+1;
	}
	return turnback;	
}


//clone una interface realization
operation InterfaceRealization cloneInterfaceRealization() : InterfaceRealization {
	var newRealization : InterfaceRealization = new InterfaceRealization;
	newRealization.name = self.name;
	newRealization.client = self.client;
	newRealization.supplier = self.supplier;
	newRealization.contract = self.contract;
	
	return newRealization;
}

//clone una operation
operation Operation cloneOperationInto(component : Component) : Operation{
	var newOperation = new Operation;
	newOperation.name = self.name + "_Cloned";
	
	component.ownedOperation.add(newOperation);
	
	newOperation.cloneOwnedParameterFrom(self);
	
	newOperation.cloneAppliedStereotypesFrom(self);
	
	newOperation.cloneReturnTypeFrom(self);
	
	return newOperation;
}

//clone owned parameter
operation Operation cloneOwnedParameterFrom(op : Operation){
	self.ownedParameter = op.ownedParameter.clone();
}

//clone i parametri di un operazione
operation Operation cloneReturnTypeFrom(op : Operation){
	if(op.getType().isDefined())
		self.setType(op.getType());
}

//recupero la lista dei process node che hanno un legame con l'operazione
operation Operation getProcessNodes() : List(Node){
	var returnValue : List(Node) = new List(Node);
	
	for(node in Node.allInstances){
		for(deployment in node.deployment){
			var listOfArtifacts = deployment.deployedArtifact;
			for(art in listOfArtifacts){
					if( art.hasRepresentationOf(self.class) ){
						returnValue.add(node);
					}
				}
			}
	}
	return returnValue;
}

//recupero gli UseCase relativi all'operazione
operation Operation getUseCases() : List(UseCase){
	var returnValue : List(UseCase) = new List(UseCase);
	
	for(interaction in Interaction.allInstances){
		if( interaction.hasOperation(self) ){
			returnValue.add(interaction.namespace);
		}
	}
	return returnValue;
}

//splitta il componente
operation Operation splitComponent() : Component{
	
	var selfComponent = self.class; //recupero il componente che possiede l'operazione critica
	var selfPackage = self.getNearestPackage(); //recupero il package contenitore dell'operazione critica
	
	var splittedComponent : Component = new Component; //creo il componente splittato
	splittedComponent.name = self.class.name + " Splitted";
	selfPackage.addElement(splittedComponent); //aggiungo il componente splittato al package del componente sorgente
	splittedComponent.cloneAppliedStereotypesFrom(selfComponent); //clono gli stessi stereotipi del componente sorgente
	
	splittedComponent.moveInterfacesRealizationFrom(selfComponent, self);
	
	var listOfUsedProvidedInterfaces : List(Interface) = selfComponent.getAllUsedIntefacesRequiredsBy(self); //TODO vedere il nuovo modello

	return splittedComponent;
}

//recupero tutti i message dell'operazione
operation Operation getAllOwnMessages() : List(Message){
	var returnValue : List(Message) = new List(Message);
	
	for(message in Message.allInstances){
		if(message.signature == self){
			returnValue.add(message);
		}
	}
	return returnValue;
}

//recupero tutti gli interaction che contengono l'op critica
operation Operation getAllInteractions() : List(Interaction){
	var returnValue : List(Interaction) = new List(Interaction);
	for(interaction in Interaction.allInstances){
		for(message in self.getAllOwnMessages()){
			if(message.namespace == interaction){
				returnValue.add(interaction);
				break;
			}
		}
	}
	return returnValue;
}

operation Operation getMessageIn(interaction : Interaction) : Message{
	var mes = interaction.getMessages()->selectOne(iterator : Message | iterator.getSignature() == self);
	return mes;
}

operation Operation getUsages() : List(Usage){
	return Usage.allInstances->select(usage : Usage |
				usage.getSuppliers()->exists(supplier : Operation | supplier == self) or
					usage.getClients()->exists(client : Operation | client == self)
			);
}


/***********************

	IT MUST BE CHECKED	

************************/
//FIXME Check the behavior
operation Operation moveIntoComponent(component : Component){
	var usages = self.getUsages()->select(usage : Usage | 
		(usage.getSuppliers().size() == 1 and usage.getSuppliers()->first() == self) or 
			(usage.getClients().size() == 1 and usage.getClients()->first() == self));
			
	component.addUsages(usages);
	component.moveOperation(self);
}

operation Operation redeployOnNearLessUsedNode() : Boolean{

	var listOfCriticSourceNode = self.PaF_F_maxHwUtil(); 
	var listOfNearLessUsed : List(Node) = new List(Node);
	
	for(node in listOfCriticSourceNode){
		var listOfNeighbours = node.getDirectlyLinkedNode(); //lista dei nodi vicini
		if(listOfNeighbours.isUndefined() or listOfNeighbours.size() == 0){
			//non esistono vicini al nodo
			return false;
			//break;
		}
		
		var lessNode : Node = listOfNeighbours->selectOne(
			node : Node | node.hasStereotype("GaExecHost") and
				node.getValue(node.getStereotype("GaExecHost"), "utilization").isDefined()
		);
		
		if(lessNode.isUndefined()) return false;
		var utilization : Real = lessNode.getValue(lessNode.getStereotype("GaExecHost"), "utilization")->first().asReal();
		
		for(neighbour in listOfNeighbours){
			if(neighbour.hasStereotype("GaExecHost")){
				var nearNodeUtilization = neighbour.getValue(lessNode.getStereotype("GaExecHost"), "utilization")->first();
				if(nearNodeUtilization.isDefined() and nearNodeUtilization.asReal() < utilization){
					lessNode = nearNode;	
					utilization = nearNodeUtilization;
				}
			}
		}
		listOfNearLessUsed.add(lessNode);
		if(listOfNearLessUsed.isUndefined() or listOfNearLessUsed.size() == 0) return false;
		self.class.redeployOn(listOfNearLessUsed->first(), node);
	}
	//deploy il componente splittato sul primo nodo della lista dei vicini meno utilizzati
	
	return true;
}

//individuare un nome migliore :)
operation Operation dynamicFixing(component : Component) {
	var interaction = self.getAllInteractions()->first();
	var sourceLifeline = component.getLifeline(interaction);
	var lifeline = interaction.createLifeline(self.class.name+"lifeline"); //L2
	
	var spProp = interaction.createOwnedAttribute(self.class.name, self.class);
	
	var besL2 : BehaviorExecutionSpecification = new BehaviorExecutionSpecification;
	var messageEnd : ExecutionOccurrenceSpecification = new ExecutionOccurrenceSpecification;
	
	lifeline.setRepresents(spProp);
	
	lifeline.cloneAppliedStereotypesFrom(sourceLifeline);
	lifeline.setVisibility(sourceLifeline.getVisibility());
	
	var indexOf : Integer = interaction.getIndexOf(self.getMessageIn(interaction).getReceiveEvent());
	interaction.addFragmentAt(besL2,indexOf+1);
	interaction.addFragmentAt(messageEnd, interaction.getIndexOf(besL2)+1);
	
	sourceLifeline.removeInteractionFragment(self.getMessageIn(interaction).getReceiveEvent());
	
	besL2.start = self.getMessageIn(interaction).getReceiveEvent();
	besL2.finish = messageEnd;
	
	lifeline.getCoveredBys().add(self.getMessageIn(interaction).getReceiveEvent());
	lifeline.getCoveredBys().add(besL2);
}