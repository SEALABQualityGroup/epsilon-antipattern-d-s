import "antipattern/PaF.eol";
import "antipattern/CPS.eol";
//import "antipattern/Blob.eol";
//import "antipattern/EP.eol";


//libraries
import "library/element.eol";
import "library/package.eol";
import "library/component.eol";
import "library/operation.eol";
import "library/interaction.eol";
import "library/artifact.eol";
import "library/manifestation.eol";
import "library/node.eol";
import "library/lifeline.eol";

import "fixing/splitting.eol";


/*********************************************************************************************
 *																							 *
 *	 								Pipe and Filter 										 *
 *							Antipattern Detection and Validation					 		 *
 *																							 *
 *********************************************************************************************/

context Operation {
	critique PaF {
		check {
			if(self.PaF_F_probExec() and 
					self.PaF_resDemand() and
						(self.PaF_F_throughtput().size() > 0 or self.PaF_F_maxHwUtil().size() > 0 ) ){
							return false;
							
			}
			return true;
		}
		message : 'PaF <Operation> ' + self.name
		fix {
			title : "Move it to a new Component deployed to a new Node"
			
			do {
					self.moveToNewComponentDeployedOnNewNode(); 
			}
		}
		fix{
			title : "Move it to a new Component deployed to the less used neighbour Node"
			do{
				//FIXING 2
				if(not self.moveToNewComponentDeployedOnNearLessUsedNode())
					"there was an error".println();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.class.name+" to the less used neighbour Node"
			do{
				//FIXING 3
				self.redeployOnNearLessUsedNode();
			}
		}
		fix{
			title : "Change its owning Component from "+self.class.name+" to the one with the lowest demand"
			do{
				//FIXING 4
				self.moveToLessCriticalComponent();
			}
		}
		
	}
}

/*********************************************************************************************
 *																							 *
 *	 							Concurrent Processing Systems 								 *
 *							Antipattern Detection and Validation			     			 *
 *																							 *
 *********************************************************************************************/
 
context Node {
	critique CPS {
		check {
			if(self.F_maxQl() and self.F_HwUtil())
				return false;
			return true;
		}
		message : 'CPS <' + self.type.name + '> ' + self.name
		fix {
			title : "Move it to a new Component deployed to a new Node"
			
			do {
					self.moveToNewComponentDeployedOnNewNode(); 
			}
		}
		fix{
			title : "Move it to a new Component deployed to the less used neighbour Node"
			do{
				//FIXING 2
				if(not self.moveToNewComponentDeployedOnNearLessUsedNode())
					"there was an error".println();
			}
		}
		fix{
			title : "Redeploy its owning Component "+self.name+" to the less used neighbour Node"
			do{
				//FIXING 3
				self.redeployOnNearLessUsedNode();
			}
		}
		fix{
			title : "Change its owning Component from "+self.name+" to the one with the lowest demand"
			do{
				//FIXING 4
				self.moveToLessCriticalComponent();
			}
		}
	}
}



/*********************************************************************************************
 *																							 *
 *	 										Blob  											 *
 *							Antipattern Detection and Validation							 *
 *																							 *
 *********************************************************************************************/
/*
	BLOB
*
context Artifact {
	
	guard : (not self.getManifestedComponentStereotyped("PaRunTInstance").isEmpty())
				//and self.getManifestedComponent().hasStereotype('PaRunTInstance')
	critique Blob {
		check {
			--return self.satisfies('Blob_static') and self.satisfies('Blob_deployment');
			return self.Blob_static() or self.Blob_deployment();
		}
		message : 'Blob <' + self.type.name + '> ' + self.name
		fix {
			guard : self.getDeployNode().isDefined() 
				and self.getDeployNode().getNodeNeighbours().isDefined() 
					and self.getDeployNode().getNodeNeighbours().getLessUsedNode().isDefined()
			title : 'Redeploy the Blob Artifact on the less used neighbour Node'
			do {
				var nodeNeighbours := self.getDeployNode().getNodeNeighbours();
				var lessUsedNode : Node := nodeNeighbours.getLessUsedNode();
				var deployment := self.getDeployNode().deployment->selectOne(d | d.getDeployedArtifacts()->includes(self));
				self.getDeployNode().deployment->remove(deployment);
				lessUsedNode.deployment->add(deployment);
			}
		}
		fix {
			title : 'Mirror the Blob Artifact on a clone of the Blob Node'
			do {
				var selfCopy := self.clone();
				var newDeployment := new Deployment;
				var deployedArtifacts := new Sequence;
				deployedArtifacts.add(selfCopy);
				newDeployment.deployedArtifact = deployedArtifacts;
				var selfDeployNodeCopy := self.getDeployNode().clone();
				selfDeployNodeCopy.deployment->add(newDeployment);
			}
		}
	}
}
*/

/*********************************************************************************************
 *																							 *
 *	 								Extensive Processing  									 *
 *							Antipattern Detection and Validation							 *
 *																							 *
 *********************************************************************************************/

/*
	Extensive Processing Antipattern Detection and Validation

context Component{
	guard : self.hasStereotype('PaRunTInstance') 
	critique EP{
		check{
			if(self.getOwnedOperations().size() < 2 and
				self.EP_resDemand()){
				return true;
			}
			return false;
		}
		message : 'Extensive Processing for <'+self.type.name+'> '+self.name
		fix{
			title : "Fix title"
			do{
				//TODO
				/*
					------Static------
					1. creare un nuovo componente
					2. spostare la seconda operatione nel nuovo componente
						
					------Deploy -----
					1. creare un nuovo nodo
					2. deployare il nuovo componente sul nuovo nodo
								
					-----Dynamic-------
					1. spostare la seconda operazione nella seconda lifeline
					2. mantenere le due operazioni in un alternative fragment
			
				
			}
		}
	}
}
*/
--context Component {
--	
--	guard : self.hasStereotype('PaRunTInstance')
--	
--	critique Blob {
--		check {
--			--return self.satisfies('Blob_static') and self.satisfies('Blob_deployment');
--			return self.Blob_static() or self.Blob_deployment();
--		}
--		message : 'Blob <' + self.type.name + '> ' + self.name
--	}
--
--}

--context Node {
--
--	guard : self.hasStereotype('GaExecHost')
--	
--	critique CPS {
--		check {
--			return self.CPS_deployment_queue() or self.CPS_deployment_unbalancedNodes();
--		}
--		message : 'CPS <' + self.type.name + '> ' + self.name
--		fix {
--			guard : self.hasCriticalComponent() and self.getUnbalancedNodes().isDefined() and self.getUnbalancedNodes().getLessUsedNode().isDefined()
--			title : 'Redeploy the critical Component on the less used CPS Node'
--			do {
--				var criticalComponent := self.getCriticalComponent();
--				UserInput.inform('Node ' + self.name + 
--						'\nCritical Component: ' + criticalComponent->asString());
--				var unbalancedNodes := self.getUnbalancedNodes();
--				var lessUsedNode : Node := unbalancedNodes.getLessUsedNode();
--				var deployment := self.deployment->select(d | d.deployedArtifact->first().isTypeOf(Artifact) and d.deployedArtifact->first().getManifestedComponent() == criticalComponent)->first();
--				--UserInput.inform('Node ' + self.name + 
--				--	'\nOld Deployment: ' + oldDeployment);
--				--var newDeployment : new Deployment;
--				--newDeployment.deployedArtifact = oldDeployment.deployedArtifact;
--				lessUsedNode.deployment->add(deployment);
--				self.deployment->remove(deployment);
--				--UserInput.inform('Node ' + self.name + 
--				--	'\nNew Deployment: ' + newDeployment.name);
--					--}
--				--}
--			}
--		}
--	}
--
--}