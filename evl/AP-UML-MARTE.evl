/////////////////////////////////////////////////// ANTIPATTERN RULES ///////////////////////////////////////////////////////
/*import "components.eol";
import "artifacts.eol";
import "nodes.eol";

import "supportingElements.eol";
import "supportingOperation.eol";
import "supportingComponents.eol";
import "supportingArtifacts.eol"; 
import "supportingNodes.eol";
*/

import "antipattern/PaF.eol";
//import "antipattern/EP.eol";


//libraries
import "library/element.eol";
import "library/package.eol";
import "library/component.eol";
import "library/operation.eol";
import "library/interaction.eol";
import "library/artifact.eol";
import "library/manifestation.eol";
import "library/node.eol";
import "library/lifeline.eol";

//fixing
import "fixing/splitting.eol";

 

///////////////////////////// TOP-LEVEL RULES /////////////////////////////////

/**
	Pipe and Filter Antipattern Detection and Validation
*/
context Operation {
	guard : self.hasStereotype('GaStep') and self.hasStereotype('GaScenario')
	
	critique PaF {
		check {
			if(self.PaF_F_probExec() and 
					self.PaF_resDemand() and
						(self.PaF_F_throughtput().size() > 0 or self.PaF_F_maxHwUtil().size() > 0 ) ){
							"bingo".println();
							return false;
							
			}
			return true;
		}
		message : 'PaF <Operation> ' + self.name
		fix {
			title : 'New component and new node'
			do {
					//TODO pt1
					--var numberOfSplitting = UserInput.promptInteger("Indicami il numero di splitting da fare ( default = 1 )", 1);
					--var percentageOfReduction = UserInput.promptReal("Indicami la percentuale di riduzione (default 0.5)", 50);
					--self.splitting(numberOfSplitting, percentageOfReduction);
					--self.splitting(1, 20);
					self.splittingComponent(20.0);
			}
		}
		fix{
			title : 'New component and node near less used'
			do{
				//TODO pt2
				self.deployToNodeNearLessUsed();
			}
		}
		fix{
			title : 'Redeploy component on node Near Less used'
			do{
				//TODO pt3
			}
		}
		fix{
			title : 'Redeploy on the component less used on node near less used'
			do{
				//TODO pt4
			}
		}
		
	}
}

/*
	Extensive Processing Antipattern Detection and Validation

context Component{
	guard : self.hasStereotype('PaRunTInstance') 
	critique EP{
		check{
			if(self.getOwnedOperations().size() < 2 and
				self.EP_resDemand()){
				return true;
			}
			return false;
		}
		message : 'Extensive Processing for <'+self.type.name+'> '+self.name
		fix{
			title : "Fix title"
			do{
				//TODO
				/*
					------Static------
					1. creare un nuovo componente
					2. spostare la seconda operatione nel nuovo componente
						
					------Deploy -----
					1. creare un nuovo nodo
					2. deployare il nuovo componente sul nuovo nodo
								
					-----Dynamic-------
					1. spostare la seconda operazione nella seconda lifeline
					2. mantenere le due operazioni in un alternative fragment
			
				
			}
		}
	}
}




/*context Artifact {
	
	guard : self.getManifestedComponent().isDefined() 
				and self.getManifestedComponent().hasStereotype('PaRunTInstance')
				
	critique Blob {
		check {
			--return self.satisfies('Blob_static') and self.satisfies('Blob_deployment');
			return self.Blob_static() or self.Blob_deployment();
		}
		message : 'Blob <' + self.type.name + '> ' + self.name
		fix {
			guard : self.getDeployNode().isDefined() 
				and self.getDeployNode().getNodeNeighbours().isDefined() 
					and self.getDeployNode().getNodeNeighbours().getLessUsedNode().isDefined()
			title : 'Redeploy the Blob Artifact on the less used neighbour Node'
			do {
				var nodeNeighbours := self.getDeployNode().getNodeNeighbours();
				var lessUsedNode : Node := nodeNeighbours.getLessUsedNode();
				var deployment := self.getDeployNode().deployment->selectOne(d | d.getDeployedArtifacts()->includes(self));
				self.getDeployNode().deployment->remove(deployment);
				lessUsedNode.deployment->add(deployment);
			}
		}
		fix {
			title : 'Mirror the Blob Artifact on a clone of the Blob Node'
			do {
				var selfCopy := self.clone();
				var newDeployment := new Deployment;
				var deployedArtifacts := new Sequence;
				deployedArtifacts.add(selfCopy);
				newDeployment.deployedArtifact = deployedArtifacts;
				var selfDeployNodeCopy := self.getDeployNode().clone();
				selfDeployNodeCopy.deployment->add(newDeployment);
			}
		}
	}
}

context Node {
	guard : self.hasStereotype('GaExecHost')
	critique CPS {
		check {
			return self.CPS_deployment_queue() or 
				   self.CPS_deployment_unbalancedNodes();
		}
		message : 'CPS <' + self.type.name + '> ' + self.name
		fix {
			guard : self.hasCriticalArtifact() and 
					self.getUnbalancedNodes().isDefined() and 
					self.getUnbalancedNodes().getLessUsedNode().isDefined()
			title : 'Redeploy the critical Artifact on the less used CPS Node'
			do {
				var criticalArtifact := self.getCriticalArtifact();
				var lessUsedNode : Node := self.getUnbalancedNodes().getLessUsedNode();
				var deployment := self.deployment->selectOne(d | d.getDeployedArtifacts()
															->includes(criticalArtifact));
				self.deployment->remove(deployment);
				lessUsedNode.deployment->add(deployment);
			}
		}
		fix {
			guard : self.hasCriticalArtifact()
			title : 'Mirror the critical Artifact on a clone of the CPS Node'
			do {
				var criticalArtifact := self.getCriticalArtifact();
				var criticalArtifactCopy := criticalArtifact.clone();
				var selfCopy := self.clone();
				var newDeployment := new Deployment;
				var deployedArtifacts := new Sequence;
				deployedArtifacts.add(criticalArtifactCopy);
				newDeployment.deployedArtifact = deployedArtifacts;
				selfCopy.deployment->add(newDeployment);
			}
		}
	}
}
*/
--context Component {
--	
--	guard : self.hasStereotype('PaRunTInstance')
--	
--	critique Blob {
--		check {
--			--return self.satisfies('Blob_static') and self.satisfies('Blob_deployment');
--			return self.Blob_static() or self.Blob_deployment();
--		}
--		message : 'Blob <' + self.type.name + '> ' + self.name
--	}
--
--}

--context Node {
--
--	guard : self.hasStereotype('GaExecHost')
--	
--	critique CPS {
--		check {
--			return self.CPS_deployment_queue() or self.CPS_deployment_unbalancedNodes();
--		}
--		message : 'CPS <' + self.type.name + '> ' + self.name
--		fix {
--			guard : self.hasCriticalComponent() and self.getUnbalancedNodes().isDefined() and self.getUnbalancedNodes().getLessUsedNode().isDefined()
--			title : 'Redeploy the critical Component on the less used CPS Node'
--			do {
--				var criticalComponent := self.getCriticalComponent();
--				UserInput.inform('Node ' + self.name + 
--						'\nCritical Component: ' + criticalComponent->asString());
--				var unbalancedNodes := self.getUnbalancedNodes();
--				var lessUsedNode : Node := unbalancedNodes.getLessUsedNode();
--				var deployment := self.deployment->select(d | d.deployedArtifact->first().isTypeOf(Artifact) and d.deployedArtifact->first().getManifestedComponent() == criticalComponent)->first();
--				--UserInput.inform('Node ' + self.name + 
--				--	'\nOld Deployment: ' + oldDeployment);
--				--var newDeployment : new Deployment;
--				--newDeployment.deployedArtifact = oldDeployment.deployedArtifact;
--				lessUsedNode.deployment->add(deployment);
--				self.deployment->remove(deployment);
--				--UserInput.inform('Node ' + self.name + 
--				--	'\nNew Deployment: ' + newDeployment.name);
--					--}
--				--}
--			}
--		}
--	}
--
--}